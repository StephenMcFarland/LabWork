  //this one took way too long. lots of not working code at first. ugh.
     public int removeElement(int[] nums, int val) {
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==val){
                nums[i]=101;
            }else{count++;}
        }
        Arrays.sort(nums);
        //int k=findFirst(nums,nums.length,101);
        //int k=Arrays.asList(nums).indexOf(101);
        //int k = nums.indexOf(101);
        //int k= Arrays.binarySearch(nums, 101);
//         int i=0;
//         while(nums[i]<=101){
            
//             i++;
//         }
        return count;
    }
  
  
  
  
      public void merge(int[] nums1, int m, int[] nums2, int n) {
        for(int i=0;i<nums2.length;i++){
            nums1[i+m]=nums2[i];
        }
        Arrays.sort(nums1);
        
    }
  
  
  
  public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        boolean contains = false;
   
        int i = 0;
        
        for(int j = 1;j<nums.length;j++) { 
            if(nums[i] == nums[j]) {
                contains = true;
                break;
            }
            i++;
        }
        return contains; 
    }
 
 
 
 
 
    public int fib(int n) {
        int sum=0;
        int n1=1;
        int n2=0;
        
        for(int i=0;i<=n;i++){
            sum = n1+n2;
            n1=n2;
            n2=sum;
        }
        return n1;




    public int removeDuplicates(int[] nums) {
//         int prev= nums[0];
//         int max=nums[nums.length-1];
        
//         for(int i=1;i<nums.length;i++){
//             if(prev==nums[i]){
//                 nums[i]=101;
//             }else{
//                 prev=nums[i];
//             }
            
//         }
//         Arrays.sort(nums);
//         int index = nums.length-1;
//         while(index>0){
//             if(nums[index]==max){
//                 break;
//             }else{
//                 index--; 
//             }
           
//         }
//         return index;

         if(nums.length == 0) {
            return 0;
        }
        int i = 0;
        
        for(int j = 1;j<nums.length;j++) { // two pointers i = 0; j = i + 1
            if(nums[i] != nums[j]) {
                i++;
                nums[i] = nums[j]; // replace the current with the new unique number found as nums[i] != nums[j]
            }
        }
        return i + 1; // index being based on 0th 
    }
}
 
 
 
 
 
 
 
 
 
 
 
 public int[] twoSum(int[] nums, int target) {
        
        int bi=0;
        int ei=0;
        int[] ia = new int[2];
        
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==target){
                    bi=i;
                    ei=j;
                    break;
                }
            }
          
        }
          ia[0]=bi;
            ia[1]=ei;
            return ia;
            }
            
            Runtime: 43 ms, faster than 40.63% of Java online submissions for Two Sum.
Memory Usage: 38.9 MB, less than 93.37% of Java online submissions for Two Sum.